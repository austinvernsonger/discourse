import PrettyText from 'discourse/lib/pretty-text';

// Run the MDTest spec
module("MDTest");

// This is cheating, but the trivial differences between sanitization
// do not affect formatting.
function normalize(str) {
  return str.replace(/\n\s*/g, '').
             replace(/ \/\>/g, '>').
             replace(/    ?/g, "\t").
             replace(/&#34;/g, '&quot;');
}

// We use a custom sanitizer for MD test that hoists out comments. In Discourse
// they are stripped, but to be compliant with the spec they should not be.
function sanitizerFunction(result) {
  let hoisted;
  const m = result.match(/<!--[\s\S]*?-->/g);
  if (m && m.length) {
    hoisted = [];
    for (let i=0; i<m.length; i++) {
      const c = m[i];
      const id = md5("discourse:hoisted-comment:" + i);
      result = result.replace(c, id);
      hoisted.push([c, id]);
    }
  }

  result = Discourse.Markdown.sanitize(result);
  if (hoisted) {
    hoisted.forEach(tuple => result = result.replace(tuple[1], tuple[0]));
  }

  return result;
}

function md(input, expected, text) {
  const cooker = new PrettyText({ traditionalMarkdownLinebreaks: true, sanitizerFunction  });
  const result = cooker.cook(input);
  const resultNorm = normalize(result);
  const expectedNorm = normalize(expected);
  const same = (result === expected) || (resultNorm === expectedNorm);

  if (same) {
    ok(same, text);
  } else {
    equal(resultNorm, expectedNorm, text);
  }
};

test("first", function(){
  equal(1, 1, "cool")
});

<%
  def mdtest_suite
    result = ""
    Dir.glob("#{Rails.root}/test/javascripts/mdtest/fixtures/*.text").each do |f|

      filename_no_ext = f.sub(/\.text$/, '')
      filename = Pathname.new(filename_no_ext)

      text = File.read(f)
      html = File.read("#{filename_no_ext}.xhtml");
      result << "test(\"#{filename}\", function() { md(#{text.to_json}, #{html.to_json}, 'passes MDTest'); });\n"
    end
    result
  end
%>

<%= mdtest_suite %>
